深入理解 Java 虚拟机
=====
JVM 高级特性与最佳实践

周志明 著

# 第一部分 走进 Java
## 第1章 走进 Java
本章主要内容:

- 概述
- Java 技术体系
- Java 发展史
- 展望 Java 技术的未来
- 实战: 自己编译 JDK


# 第二部分 自动内存管理机制
# 第2章 Java 内存区域与内存溢出异常
本章主要内容:

- 概述
- 运行时数据区域
- 对象访问
- 实战: OutOfMemoryError 异常

## 2	.1 概述
#### 自动内存管理机制有啥利与弊？
利：

- 不需要给每个 new 操作写配对的 `delete/free` 代码（c/c++ 没这么“省心”）
- 不容易` 内存溢出` 和 `内存泄露`

弊:

- 没有最高权力，一旦出现内存泄漏或内存溢出，如果不了解虚拟机的话，排查问题就很艰难了

## 2.2 运行时数据区域
JVM 在执行 Java 程序的过程中，会把管理的内存划分为多个不同的数据区域。如下所示:

<div align="center"> <img src="pics/图2.1.png" width="500" style="zoom:100%"/> </div><br>
<div align="center"> <img src="pics/11548742157520.gif" width="450"/> </div><br>

### 2.2.1 程序计数器
> 什么是程序计数器？

- 是一块较小的内存空间
- 可以看作当前线程所执行的 `行号指示器`
- 这个内存区域是**唯一一个**在 JVM 规范中没有规定任何 OutOfMemoryError 情况的区域

> 有什么作用呢？

- `字节码解释器` 工作时通过改变 `程序计数器` 的值来选取下一条要执行的字节码指令
- 分支、循环、跳转、异常处理、线程恢复等基础功能都依赖 `程序计数器` 来完成


JVM 的多线程实现: 通过线程的轮流切换并分配处理器执行时间的方式实现

任意时刻，一个处理器都**只会执行一条线程**中的指令。为了切换后恢复到正确的执行过程，每条线程需要一个独立的程序计数器。

##### “线程私有”的内存
各条线程之间的计数器互不影响，独立存储，这类内存区域为“线程私有”的内存

- 若线程执行的是 java 方法 ==> 程序计数器记录正在执行的虚拟机字节码指令的地址
- 若线程执行的是 native 方法 ==> 程序计数器值为空 (undefined)

### 2.2.2 java 虚拟机栈
java 虚拟机栈(Java Virtual Mashine Stacks) 线程私有，与线程的生命周期相同。

JVM 描述 java 方法执行的内存模型:每个方法在被_执行的时候_都会同时创建一个 「栈帧」。

每个方法从被调用 ==》执行完成的过程， 对应一个 栈帧 在虚拟机栈中 从 入栈 ==〉 出栈 的过程。

<div align="center"> <img src="pics/11548741556940.gif" width="500"/> </div><br>

可以通过 -Xss 这个虚拟机参数来指定每个线程的 Java 虚拟机栈内存大小：

```java
java -Xss512M HackTheJava
```

- **栈帧作用**
	- 用于存储局部变量表、操作栈、动态链接、方法出口等信息

- 局部变量表存放信息
 - 编译期可知的 各种基本数据类型(boolean、byte、char、short、int、float、long、double)
 - 对象引用( reference 类型)
 - returnAddress类型(指向一条字节码指令的地址)

reference 类型: 可能是指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置

- 其他局部变量表
	- 64 位长度的 long 和 double 类型的数据 占用 2 个局部变量空间(Slot)； 其余只占用 1 个
	- 局部变量表所需空间在 **编译期间** 完成分配 : 所以进入一个方法时，该方法需要在 帧中分配多大的局部变量空间是 _完全确定的_ ，方法运行期间局部变量表大小不会改变

- JVM 规范该区域的两种异常状况:
	- stackOverfloeError 异常: 线程请求的栈深度 大于 虚拟机允许的深度
	- OutOfMemoryError 异常: 如果虚拟机可以动态扩展，而扩展时没有办法申请到足够的内存

### 2.2.3 本地方法栈
#### 与 java 虚拟机栈作用相似，区别在哪？
- java 虚拟机栈为虚拟机执行 **java 方法(即字节码)**服务
- 本地方法栈为虚拟机使用到的 **Native 方法**服务

> 备注: JVM 规范对本地方法栈中方法使用的语言、使用方式与数据结构没有强制的规定 ===》具体的 JVM 可以自由实现

本地方法一般是用其它语言（C、C++ 或汇编语言等）编写的，并且被编译为基于本机硬件和操作系统的程序，对待这些方法需要特别处理。【 java 关键字 transient 标识的变量不能被序列化】

<div align="center"> <img src="pics/11548742010310.gif"/> </div><br>

### 2.2.4 java 堆
java 堆是被**所有线程共享**的一块内存区域，在**虚拟机启动时创建**。

- java 堆
	- 唯一目的: 存放对象实例
	- 几乎所有对象都在这里分配内存
	- 是垃圾收集的主要区域（"GC 堆"）

- GC 堆
	- 1.内存回收的角度: 现代收集器基本采用 `分代收集算法`==》细分为 新生代 + 老年代 ，再细分有 Eden 空间 + From Survivor 空间 + To Survivor 空间 等
	- 2.内存分配的角度: 线程共享的 java 堆可能划分多个线程私有的分配缓冲区

> 无论如何划分 GC 堆，对于存放的内容无关 ===》无论哪个区域，存储的都是对象实例
> 
> 划分的目的是为了更好的 `回收内存` 或者更快的 `分配内存`

现代的垃圾收集器基本都是采用分代收集算法，其主要的思想是针对不同类型的对象采取不同的垃圾回收算法。可以将堆分成两块：

- 新生代（Young Generation）
- 老年代（Old Generation）

堆不需要连续内存，并且可以动态增加其内存，增加失败会抛出 OutOfMemoryError 异常。

可以通过 -Xms 和 -Xmx 这两个虚拟机参数来指定一个程序的堆内存大小，第一个参数设置初始值，第二个参数设置最大值，如下所示：

```java
java -Xms1M -Xmx2M HackTheJava
```

### 2.2.5 方法区
用于存放已被加载的 `类信息、常量、静态变量、即时编译器编译后的代码`等数据。(JVM 规范将其描述为堆的一个逻辑部分)

- 与 java 堆一样，被各个线程共享的内存区域

和堆一样不需要连续的内存，并且可以动态扩展，动态扩展失败一样会抛出 OutOfMemoryError 异常。

对这块区域进行垃圾回收的主要目标是对 `常量池的回收和对类的卸载` ，但是一般比较难实现，“成绩”不太好。

HotSpot 虚拟机把它当成永久代来进行垃圾回收。但很难确定永久代的大小，因为它受到很多因素影响，并且每次 Full GC 之后永久代的大小都会改变，所以经常会抛出 OutOfMemoryError 异常。为了更容易管理方法区，从 JDK 1.8 开始，移除永久代，并把方法区移至元空间，它位于 `本地内存` 中，而不是虚拟机内存中。

### 2.2.6 运行时常量池
运行时常量池是方法区的一部分。

- 作用: 用于存放编译期生成的各种**字面量和符号引用**，在类加载后被放入这个区域

除了在编译期生成的常量，还允许**动态生成**，例如 String 类的 intern()。

> 动态生成: 运行期间也可能将新的常量放入常量池中

异常：受到方法区内存的限制，无法申请到更多内存时就会抛出 `OutOfMemoryError `异常。

### 2.2.7 直接内存(Direct Memory)
> 备注: 这部分不是 JVM 运行时数据区的一部分，也不是 JVM 规范定义的内存区域。但是频繁被使用到，而且会抛  `OutOfMemoryError `异常，顺带就介绍一下咯。

在 JDK 1.4 中新引入了 NIO 类，引入了一种基于通道(chennel)与缓冲区(buffer)的 I/O 方式，它可以使用 `Native 函数库`直接分配`堆外内存`，然后通过 Java 堆里的 DirectByteBuffer 对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了在堆内存和堆外内存来回拷贝数据。

<font color="red" size=4>Java 堆里的 DirectByteBuffer 对象如何操作？ 了解一下 NIO</font>

## 2.3 HotSpot 虚拟机对象探密
### 2.3.1 对象的创建
在语言层面上，创建对象(如克隆、反序列化)一般就一个 new 关键字====》看上去好像很简单，那 JVM 中是什么样的呢？

虚拟机遇到一条 new 指令 ====〉

- 1.检查这个指令的参数是否能在**常量池**中定位到一个**类的符号引用**（常量池中找是否存在引用），检查这个引用的类是否被**加载、解析、初始化**过。 若没有，则先加载(详见第 7 章)
- 2.类加载通过后，VM 为新生对象**分配内存**，这个任务等同于把一块**确定大小的内存**从 java 堆中划分出来

> 这里划分存在两种情况
> 
> 选用哪种方式由 java 堆是否规整决定，规整又由采用的垃圾收集器是否带有压缩整理功能决定。

- 情况1: java 堆中内存绝对规整===》分配方式为 **“指针碰撞(Bump the Pointer)”**

> 所有用过的内存都放在一边，空闲的内存放在另一边，中间放着一个指针作为分界点的指示器，所分配内存仅仅就是把哪个指针向空闲空间挪动一段与对象大小相等的距离， 如使用 Serial、ParNew等带 Compact 过程的垃圾收集器

- 情况2: java 堆中内存不规整===》分配方式为 **“空闲列表(Free List)”**

> 使用过的内存和空闲的内存相互交错，VM 必须维护一个列表，记录哪些内存块是可用的，分配时从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录， 如使用 CMS 这种基于 Mark-Sweep 算法的垃圾收集器

- 除了划分可用空间，需要考虑另一个问题===>对象创建是非常频繁的行为，即使只是改了一个指针指向的位置，在**并发**情况下**不是线程安全**的。 

> 比如：正在给对象 A 分配内存，指针还没来得及修改，对象 B 又同时使用了原来的指针来分配内存
> 
> 解决办法1: 对内存分配动作进行**_同步处理_**——实际上 VM 采用 CAS 配上失败重试就是保证更新操作的原子性
> 
> 解决办法2: 把内存分配动作按照线程划分到不同的空间中进行====》即每个线程在 java 堆中预先分配一小块内存，称为 “本地线程分配缓冲”(Thread Local Allocation Buffer,TLAB),哪个线程要分配内存，就在哪个线程的 TLAB 上分配，只有 TLAB 用完并分配新的 TLAB 时，才需要锁定。

- 3.内存分配完成后， VM 将分配到的 **内存空间初始化为零值**(不包括对象头) ===》这一操作保证对象的实例字段在 java 代码中可以不赋初始值就可以直接使用(程序可以访问这些字段的数据类型的零值)
- 4.VM 给对象必要的设置(如这个对象是哪个类的实例、如何找到类的元数据信息、对象的哈希码、对象的 GC 分代年龄等)。这些信息保存在**对象头(Object Header)**之中
- 5.上面步骤完成，从 VM 角度看，一个新的对象诞生啦！真棒！ 但从 java 程序的角度，对象创建才刚刚开始=== 》<init> 方法还没有执行，所有字段都还为零。 所以，一般执行 new 指令之后会接着执行 <init> 方法，把对象按照程序猿的意愿进行初始化==== 》一个真正可用的对象才完全产生出来。


查看代码清单 2-1 ，了解 HotSpot 的运作过程

<div align="center"> <img src="pics/2-1.png" width="500" style="zoom:100%"/> </div><br>











